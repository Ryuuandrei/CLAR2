#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#include "raycommon.glsl"

layout(location = 0) rayPayloadEXT hitPayload prd;

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D image;
layout(set = 1, binding = 0) uniform UniformBufferObject {
    mat4 model;
    mat4 view;
    mat4 proj;
} ubo;

void main()
{
    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;

    vec4 origin    = inverse(ubo.view) * vec4(0, 0, 0, 1);
    vec4 target    = inverse(ubo.proj) * vec4(d.x, d.y, 1, 1);
    vec4 direction = inverse(ubo.view) * vec4(normalize(target.xyz), 0);

    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    rayFlags = gl_RayFlagsNoneEXT;
    float tMin     = 0.001;
    float tMax     = 10000.0;

    prd.nextOrigin = origin.xyz;
    prd.nextDirection = direction.xyz;
    prd.miss = false;

    vec3 color = vec3(1.0);

//    while (!prd.miss)
    for (int i = 0; i < 3 && !prd.miss; i++)
    {
        traceRayEXT(topLevelAS, // acceleration structure
              rayFlags,       // rayFlags
              0xFF,           // cullMask
              0,              // sbtRecordOffset
              0,              // sbtRecordStride
              0,              // missIndex
              prd.nextOrigin,     // ray origin
              tMin,           // ray min range
              prd.nextDirection,  // ray direction
              tMax,           // ray max range
              0              // payload (location = 0)
        );
        color *= 0.5;
    }
    color *= prd.hitValue;

    !prd.miss ? imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(0.0, 0.0, 0.0, 1.0)) :
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}
