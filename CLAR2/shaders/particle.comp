#version 450

struct Particle {
	vec3 position;
	vec3 velocity;
    vec4 color;
    float r;
    float theta;
};

layout (binding = 0) uniform ParameterUBO {
    float deltaTime;
} ubo;

layout(std140, binding = 1) readonly buffer ParticleSSBOIn {
   Particle particlesIn[ ];
};

layout(std140, binding = 2) buffer ParticleSSBOOut {
   Particle particlesOut[ ];
};

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

float IntensityBulge(float R, float I0, float k)
{
    return I0 * exp(-k * pow(R, 0.25));
}

float IntensityDisc(float R, float I0, float a)
{
    return I0 * exp(-R / a);
}


float Intensity(float x)
{
    float _I0 = 1.0f;
    float _k = 0.9f;
    float _a = 1.5 / 3.0f;
    float _RBulge = 2;
    return (x < _RBulge) ? IntensityBulge(x, _I0, _k) : IntensityDisc(x - _RBulge, IntensityBulge(_RBulge, _I0, _k), _a);
}

void main() 
{
    uint index = gl_GlobalInvocationID.x;

    Particle particleIn = particlesIn[index];

    particlesOut[index].velocity = particleIn.velocity;
    float newTheta = particleIn.theta + ubo.deltaTime / 2;
    particlesOut[index].theta = newTheta;
    particlesOut[index].r = particleIn.r;

    float x = particleIn.r * cos(newTheta) * 600 / 800;
    float y = particleIn.r * sin(newTheta);

    float X = x * cos(particleIn.r) - y * sin(particleIn.r);
    float Y = x * sin(particleIn.r) + y * cos(particleIn.r);

    particlesOut[index].position = vec3(X, 0, Y);
    particlesOut[index].color = vec4(1.0) * Intensity(length(particlesOut[index].position));

        
}